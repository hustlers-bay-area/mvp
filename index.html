<!DOCTYPE html> <html lang="en"> <head> <meta charset="UTF-8" /> <meta name="viewport" content="width=device-width,initial-scale=1" /> <title>CUET Document Helper</title> <style> body { font-family: 'Segoe UI', Arial, sans-serif; background: #f8fafc; margin: 0; } .container { max-width: 640px; margin: 32px auto; background: #fff; border-radius: 10px; padding: 24px 20px 32px 20px; box-shadow: 0 8px 24px #0001; } h1 { color: #1766b2; font-size: 2rem; margin-bottom: 8px; } h2 { font-size: 1.18rem; color: #234; margin-bottom: 24px; } .doc-card { background: #eaf4fb; border-radius: 8px; margin-bottom: 22px; padding: 20px 18px; box-shadow: 0 2px 8px #0002; display: flex; gap: 14px; align-items: flex-start; } .doc-info { flex: 1; } .doc-title { font-weight: 600; font-size: 1.13rem; margin-bottom: 6px; } .doc-desc { font-size: 0.98rem; margin-bottom: 10px; color: #333; } .upload-btn { border-radius: 5px; border: none; background: #1766b2; color: #fff; font-size: 1rem; padding: 7px 12px; margin-bottom: 11px; cursor: pointer; } .result { font-size: 0.97rem; margin-top: 7px; padding: 7px; border-radius: 5px; } .result.success { background: #cbf1cd; color: #295a07; } .result.error { background: #ffeaea; color: #ad3838; } .image-button { width: 110px; height: 110px; border-radius: 10px; background: linear-gradient(180deg,#ffffff,#eef7ff); border: 2px dashed #cbe7ff; display: inline-flex; align-items: center; justify-content: center; cursor: pointer; transition: transform .12s ease, box-shadow .12s ease; flex-shrink: 0; } .image-button:hover { transform: translateY(-3px); box-shadow: 0 6px 18px rgba(0,0,0,0.08); } .image-button svg { width: 48px; height: 48px; fill: #1766b2; opacity: 0.95; } .preview { margin-top: 8px; max-width: 100%; border-radius: 6px; border: 1px solid #ddd; } .controls { display:flex; gap:10px; margin-top:8px; flex-wrap:wrap; } .small-btn { padding:6px 10px; border-radius:6px; border:none; cursor:pointer; background:#0b5fb6; color:#fff; } .small-btn.ghost { background:#fff; border:1px solid #d0e7ff; color:#1766b2; } footer { color: #7b7b7b; text-align: center; font-size: 0.93rem; margin-top: 20px; } a { color: #186ee0; text-decoration: none; } a:hover { text-decoration: underline; } @media (max-width: 700px) { .container { max-width: 98vw; padding: 12px 3vw 24px 3vw; } .doc-card { flex-direction: column; align-items: stretch; } .image-button { width: 100%; height: 120px; } } </style> </head> <body> <div class="container"> <h1>CUET Document Helper</h1> <h2>Instantly check &amp; validate your document uploads for CUET 2026.</h2> <div id="app"></div> <footer> Made for students | <a href="https://www.cuet.com/cuet-documents-required" target="_blank">CUET Official Docs</a> </footer> </div> <script crossorigin src="https://unpkg.com/react@18/umd/react.development.js"></script> <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"></script> <script> const { useState, useRef } = React; /* Updated doc specs include category to identify image vs pdf. The Passport-size Photograph and Signature are image category. */ const docSpecs = [ { title: "Passport-size Photograph", accept: ".jpg,.jpeg,image/*", formats: ["jpg","jpeg"], minKb: 10, maxKb: 200, desc: "Face (80%) & ears visible, white background. JPG/JPEG, 10–200kb.", category: "image" }, { title: "Signature", accept: ".jpg,.jpeg,image/*", formats: ["jpg","jpeg"], minKb: 4, maxKb: 30, desc: "Clear, non-blurry, JPG/JPEG, 4–30kb.", category: "image" }, { title: "Category Certificate", accept: ".pdf", formats: ["pdf"], minKb: 50, maxKb: 300, desc: "SC/ST/OBC/EWS, PDF, 50–300kb.", category: "pdf" }, { title: "PwBD Certificate", accept: ".pdf", formats: ["pdf"], minKb: 50, maxKb: 300, desc: "Disability certificate, PDF, 50–300kb.", category: "pdf" }, { title: "Class 10/12 Marksheet", accept: ".pdf", formats: ["pdf"], minKb: 50, maxKb: 300, desc: "PDF, max 300kb. Upload if requested.", category: "pdf" } ]; /* Utility: read file as Data URL */ function readFileAsDataURL(file) { return new Promise((res, rej) => { const fr = new FileReader(); fr.onload = () => res(fr.result); fr.onerror = rej; fr.readAsDataURL(file); }); } /* Utility: convert dataURL to Blob (works in browsers) */ async function dataURLToBlob(dataURL) { const res = await fetch(dataURL); return await res.blob(); } /* Compress & convert image file to JPEG Blob attempting to fit [minKb,maxKb]. Strategy: - Draw image to canvas with an initial max dimension. - Try multiple quality levels (from high to low). - If still too large, reduce dimensions and repeat. - Stop when size <= maxKb or when minimal dimensions/quality reached. Returns: { blob, sizeKb, dataUrl, warning } */ async function compressImageFileToJpeg(file, minKb, maxKb, opts = {}) { const maxDimInitial = opts.maxDimension || 1200; // starting max width/height const minDim = opts.minDimension || 300; const minQuality = 0.35; const qualityStep = 0.07; const dimStep = 0.88; const dataUrl = await readFileAsDataURL(file); const img = new Image(); img.src = dataUrl; await new Promise((res, rej) => { img.onload = res; img.onerror = rej; }); let cw = img.width, ch = img.height; // scale down if larger than maxDimInitial if (Math.max(cw, ch) > maxDimInitial) { const ratio = maxDimInitial / Math.max(cw, ch); cw = Math.round(cw * ratio); ch = Math.round(ch * ratio); } const canvas = document.createElement('canvas'); const ctx = canvas.getContext('2d'); let finalBlob = null; let finalDataUrl = null; let attemptQuality = 0.92; let warning = null; // helper to get blob from canvas at specific quality function toBlobPromise(q) { return new Promise((resolve) => { canvas.toBlob((b) => resolve(b), 'image/jpeg', q); }); } // iterative reduce quality & dimensions until <= maxKb or we stop while (true) { canvas.width = cw; canvas.height = ch; // draw with white background to avoid transparent PNG artifacts ctx.fillStyle = "#ffffff"; ctx.fillRect(0, 0, cw, ch); ctx.drawImage(img, 0, 0, cw, ch); let q = attemptQuality; let blob = await toBlobPromise(q); let sizeKb = blob.size / 1024; // try dropping quality if too big while (sizeKb > maxKb && q > minQuality) { q = Math.max(minQuality, q - qualityStep); blob = await toBlobPromise(q); sizeKb = blob.size / 1024; } // if it's still too big and dimensions can be reduced, reduce and retry if (sizeKb > maxKb && Math.max(cw, ch) > minDim) { cw = Math.max(minDim, Math.round(cw * dimStep)); ch = Math.max(minDim, Math.round(ch * dimStep)); attemptQuality = 0.92; // reset quality for new dimension continue; } // At this point, sizeKb <= maxKb OR we've hit minimal dimensions/quality finalBlob = blob; finalDataUrl = await (async () => { // create dataURL from blob return await new Promise((res2) => { const fr2 = new FileReader(); fr2.onload = () => res2(fr2.result); fr2.readAsDataURL(finalBlob); }); })(); // If too small (below minKb) warn (can't realistically enlarge without losing quality) if (sizeKb < minKb) { warning = `Resulting image is ${sizeKb.toFixed(2)}kb (< ${minKb}kb). Some portals may reject extremely small images.`; } return { blob: finalBlob, sizeKb: sizeKb, dataUrl: finalDataUrl, warning }; } } /* Helper to convert blob to downloadable URL */ function blobToObjectUrl(blob) { return URL.createObjectURL(blob); } /* Component: DocCard */ function DocCard({ spec }) { const [result, setResult] = useState(""); const [resultType, setResultType] = useState(""); const [previewUrl, setPreviewUrl] = useState(null); const [downloadUrl, setDownloadUrl] = useState(null); const [processing, setProcessing] = useState(false); const fileInputRef = useRef(null); async function handleFile(file) { if (!file) return; const name = file.name || 'file'; const ext = name.split('.').pop().toLowerCase(); // Basic extension check if (!spec.formats.includes(ext) && spec.category === 'pdf') { setResultType("error"); setResult("Invalid file type! Acceptable: " + spec.formats.join(", ").toUpperCase()); return; } if (spec.category === 'image') { // For images: convert to jpeg and compress to fit spec setProcessing(true); try { const converted = await compressImageFileToJpeg(file, spec.minKb, spec.maxKb); const { blob, sizeKb, dataUrl, warning } = converted; // Check final size if (sizeKb > spec.maxKb + 1) { setResultType("error"); setResult(`Unable to compress below ${spec.maxKb}kb. Final size: ${sizeKb.toFixed(2)}kb.`); setPreviewUrl(dataUrl); const url = blobToObjectUrl(blob); setDownloadUrl(url); } else { setResultType("success"); setResult(`✓ Converted to JPG — ${sizeKb.toFixed(2)} kb. Ready to upload.`); setPreviewUrl(dataUrl); const url = blobToObjectUrl(blob); setDownloadUrl(url); if (warning) { // show warning but still success setResult(prev => prev + (" Note: " + warning)); } } } catch (err) { console.error(err); setResultType("error"); setResult("Error processing image. Try a different file."); } finally { setProcessing(false); } } else { // PDFs or other files: just validate size/extension const sizeKb = file.size / 1024; if (sizeKb < spec.minKb || sizeKb > spec.maxKb) { setResultType("error"); setResult(`Incorrect file size! Must be ${spec.minKb}-${spec.maxKb}kb. Yours is ${sizeKb.toFixed(2)}kb.`); } else { setResultType("success"); setResult("✓ Valid! Ready to upload to CUET portal."); } setPreviewUrl(null); setDownloadUrl(null); } } function onInputChange(e) { const file = e.target.files && e.target.files[0]; handleFile(file); // reset input so selecting same file again triggers change event next time e.target.value = ""; } function onIconClick() { if (fileInputRef.current) fileInputRef.current.click(); } function onDownload() { if (!downloadUrl) return; const a = document.createElement('a'); a.href = downloadUrl; // suggested filename a.download = spec.title.replace(/\s+/g, '_') + '.jpg'; a.click(); } return ( <div className="doc-card"> <div style={{flexShrink:0}}> {/* If image category, show image icon acting as button */} {spec.category === 'image' ? ( <div className="image-button" onClick={onIconClick} title={`Select ${spec.title}`}> <svg viewBox="0 0 24 24" aria-hidden="true"> <path d="M21 19V5a2 2 0 0 0-2-2H5C3.897 3 3 3.897 3 5v14a2 2 0 0 0 2 2h14a2 2 0 0 0 2-2zM8.5 11.5l2.5 3.01L13.5 12l4.5 6H6l2.5-6.5z"></path> </svg> </div> ) : ( <div style={{width:110, textAlign:'center', fontSize:12, color:'#224'}}> <div style={{fontWeight:600, marginBottom:6}}>File</div> <button className="upload-btn" onClick={() => fileInputRef.current && fileInputRef.current.click()} >Choose</button> </div> )} </div> <div className="doc-info"> <div className="doc-title">{spec.title}</div> <div className="doc-desc">{spec.desc}</div> <input ref={fileInputRef} type="file" accept={spec.accept} onChange={onInputChange} style={{ display: "none" }} /> <div style={{display:'flex', gap:8, alignItems:'center', marginTop:6, flexWrap:'wrap'}}> {spec.category !== 'image' && ( <div style={{fontSize:13, color:'#444'}}>Accepts: {spec.formats.join(', ').toUpperCase()} | Size: {spec.minKb}-{spec.maxKb}kb</div> )} {processing && <div style={{fontSize:13,color:'#1766b2'}}>Processing image...</div>} </div> {result && ( <div className={`result ${resultType}`}>{result}</div> )} {previewUrl && ( <> <img className="preview" src={previewUrl} alt="preview" /> <div className="controls"> <button className="small-btn" onClick={onDownload}>Download JPG</button> <button className="small-btn ghost" onClick={() => { setPreviewUrl(null); setDownloadUrl(null); setResult(''); setResultType(''); }}> Clear </button> </div> </> )} </div> </div> ); } function App() { return ( <div> {docSpecs.map(spec => <DocCard key={spec.title} spec={spec} /> )} </div> ); } ReactDOM.createRoot(document.getElementById('app')).render(React.createElement(App)); </script> </body> </html>
